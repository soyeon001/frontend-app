import type { DerivedApiDefinition, SetTypeSubArg, SchemaConfiguration, DataSourceConfiguration, DatasourceEngine, UnionToIntersection } from '@aws-amplify/data-schema-types';
import { type InternalModel, SchemaModelType, AddRelationshipFieldsToModelTypeFields, type BaseModelType } from './ModelType';
import type { EnumType } from './EnumType';
import type { CustomType, CustomTypeParamShape } from './CustomType';
import type { CustomOperation, CustomOperationParamShape, InternalCustom, MutationCustomOperation, QueryCustomOperation, SubscriptionCustomOperation } from './CustomOperation';
import { AllowModifier, SchemaAuthorization } from './Authorization';
import { Brand } from './util';
import { ModelRelationalField, ModelRelationalFieldParamShape } from './ModelRelationalField';
export declare const rdsSchemaBrandName = "RDSSchema";
export declare const rdsSchemaBrand: Brand<"RDSSchema">;
export type RDSSchemaBrand = Brand<typeof rdsSchemaBrandName>;
export declare const ddbSchemaBrandName = "DDBSchema";
export type DDBSchemaBrand = Brand<typeof ddbSchemaBrandName>;
type SchemaContent = BaseModelType | CustomType<CustomTypeParamShape> | EnumType | CustomOperation<CustomOperationParamShape, any>;
type AddToSchemaContent = Exclude<SchemaContent, BaseModelType>;
type AddToSchemaContents = Record<string, AddToSchemaContent>;
type NonEmpty<T> = keyof T extends never ? never : T;
type ModelSchemaContents = Record<string, SchemaContent>;
type InternalSchemaModels = Record<string, InternalModel | EnumType<any> | CustomType<any> | InternalCustom>;
export type ModelSchemaParamShape = {
    types: ModelSchemaContents;
    authorization: SchemaAuthorization<any, any, any>[];
    configuration: SchemaConfiguration<any, any>;
};
export type RDSModelSchemaParamShape = ModelSchemaParamShape;
export type InternalSchema = {
    data: {
        types: InternalSchemaModels;
        authorization: SchemaAuthorization<any, any, any>[];
        configuration: SchemaConfiguration<any, any>;
    };
};
export type BaseSchema<T extends ModelSchemaParamShape, IsRDS extends boolean = false> = {
    data: T;
    models: {
        [TypeKey in keyof T['types']]: T['types'][TypeKey] extends BaseModelType ? SchemaModelType<T['types'][TypeKey], TypeKey & string, IsRDS> : never;
    };
    transform: () => DerivedApiDefinition;
};
export type GenericModelSchema<T extends ModelSchemaParamShape> = BaseSchema<T> & Brand<typeof rdsSchemaBrandName | typeof ddbSchemaBrandName>;
export type ModelSchema<T extends ModelSchemaParamShape, UsedMethods extends 'authorization' | 'relationships' = never> = Omit<{
    authorization: <AuthRules extends SchemaAuthorization<any, any, any>>(callback: (allow: AllowModifier) => AuthRules | AuthRules[]) => ModelSchema<SetTypeSubArg<T, 'authorization', AuthRules[]>, UsedMethods | 'authorization'>;
}, UsedMethods> & BaseSchema<T> & DDBSchemaBrand;
type RDSModelSchemaFunctions = 'addToSchema' | 'addQueries' | 'addMutations' | 'addSubscriptions' | 'authorization' | 'setRelationships' | 'setAuthorization' | 'renameModelFields' | 'renameModels';
export type RDSModelSchema<T extends RDSModelSchemaParamShape, UsedMethods extends RDSModelSchemaFunctions = never, RelationshipTemplate extends Record<string, ModelRelationalField<ModelRelationalFieldParamShape, string, any, any>> = Record<string, ModelRelationalField<ModelRelationalFieldParamShape, string, any, any>>> = Omit<{
    addToSchema: <AddedTypes extends AddToSchemaContents>(types: AddedTypes) => RDSModelSchema<SetTypeSubArg<T, 'types', T['types'] & AddedTypes>, UsedMethods | 'addToSchema'>;
    /**
     * @deprecated use `addToSchema()` to add operations to a SQL schema
     */
    addQueries: <Queries extends Record<string, QueryCustomOperation>>(types: Queries) => RDSModelSchema<SetTypeSubArg<T, 'types', T['types'] & Queries>, UsedMethods | 'addQueries'>;
    /**
     * @deprecated use `addToSchema()` to add operations to a SQL schema
     */
    addMutations: <Mutations extends Record<string, MutationCustomOperation>>(types: Mutations) => RDSModelSchema<SetTypeSubArg<T, 'types', T['types'] & Mutations>, UsedMethods | 'addMutations'>;
    /**
     * @deprecated use `addToSchema()` to add operations to a SQL schema
     */
    addSubscriptions: <Subscriptions extends Record<string, SubscriptionCustomOperation>>(types: Subscriptions) => RDSModelSchema<SetTypeSubArg<T, 'types', T['types'] & Subscriptions>, UsedMethods | 'addSubscriptions'>;
    authorization: <AuthRules extends SchemaAuthorization<any, any, any>>(callback: (allow: AllowModifier) => AuthRules | AuthRules[]) => RDSModelSchema<SetTypeSubArg<T, 'authorization', AuthRules[]>, UsedMethods | 'authorization'>;
    setAuthorization: (callback: (models: BaseSchema<T, true>['models'], schema: RDSModelSchema<T, UsedMethods | 'setAuthorization'>) => void) => RDSModelSchema<T>;
    setRelationships: <Relationships extends ReadonlyArray<Partial<Record<keyof T['types'], RelationshipTemplate>>>>(callback: (models: BaseSchema<T, true>['models']) => Relationships) => RDSModelSchema<UnionToIntersection<Relationships[number]> extends infer RelationshipsDefs ? RelationshipsDefs extends Record<string, RelationshipTemplate> ? SetTypeSubArg<T, 'types', {
        [ModelName in keyof T['types']]: ModelName extends keyof RelationshipsDefs ? AddRelationshipFieldsToModelTypeFields<T['types'][ModelName], RelationshipsDefs[ModelName]> : T['types'][ModelName];
    }> : T : T, UsedMethods | 'setRelationships'>;
    renameModels: <NewName extends string, CurName extends string = keyof BaseSchema<T>['models'] & string, const ChangeLog extends readonly [CurName, NewName][] = []>(callback: () => ChangeLog) => RDSModelSchema<SetTypeSubArg<T, 'types', RenameModelArr<ChangeLog, T['types']>>, UsedMethods | 'renameModels'>;
}, UsedMethods> & BaseSchema<T, true> & RDSSchemaBrand;
type RenameModel<CurName extends string, NewName extends string, Types extends ModelSchemaContents> = {
    [Type in keyof Types as Type extends CurName ? NewName : Type]: Types[Type];
};
type RenameModelArr<ChangeLog extends readonly [string, string][], Types extends ModelSchemaContents> = ChangeLog extends readonly [
    infer CurPair extends [string, string],
    ...infer Rest extends readonly [string, string][]
] ? RenameModelArr<Rest, RenameModel<CurPair[0], CurPair[1], Types>> : Types;
/**
 * Amplify API Next Model Schema shape
 */
export type ModelSchemaType = ModelSchema<ModelSchemaParamShape>;
/**
 * Model Schema type guard
 * @param schema - api-next ModelSchema or string
 * @returns true if the given value is a ModelSchema
 */
export declare const isModelSchema: (schema: string | ModelSchemaType) => schema is ModelSchemaType;
type SchemaReturnType<DE extends DatasourceEngine, Types extends ModelSchemaContents> = DE extends 'dynamodb' ? ModelSchema<{
    types: Types;
    authorization: [];
    configuration: any;
}> : RDSModelSchema<{
    types: Types;
    authorization: [];
    configuration: any;
}>;
/**
 * The API and data model definition for Amplify Data. Pass in `{ <NAME>: a.model(...) }` to create a database table
 * and exposes CRUDL operations via an API.
 * @param types The API and data model definition
 * @returns An API and data model definition to be deployed with Amplify (Gen 2) experience (`processSchema(...)`)
 * or with the Amplify Data CDK construct (`@aws-amplify/data-construct`)
 */
export declare const schema: <Types extends ModelSchemaContents>(types: NonEmpty<Types>) => ModelSchema<{
    types: Types;
    authorization: [];
    configuration: any;
}, never>;
/**
 * Configure wraps schema definition with non-default config to allow usecases other than
 * the default DynamoDB use-case.
 *
 * @param config The SchemaConfig augments the schema with content like the database type
 * @returns
 */
export declare function configure<DE extends DatasourceEngine>(config: SchemaConfiguration<DE, DataSourceConfiguration<DE>>): {
    schema: <Types extends ModelSchemaContents>(types: NonEmpty<Types>) => SchemaReturnType<DE, Types>;
};
export declare function isCustomPathData(obj: any): obj is CustomPathData;
export type CustomPathData = {
    stack: string | undefined;
    entry: string;
};
export {};
